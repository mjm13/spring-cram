# JVM复习
## 垃圾回收
### 垃圾回收算法？不太常问
* 标记清理：标记存活的对象，清理未标记的对象，用于老年代对象回收，可能导致内存碎片。
* 标记整理：标记存活的对象，将存活的对象集中到相邻的内存地址，避免内存碎片
* 复制：在分区回收中将S0区存活对象复制到S1区连续内存中，再清理S0区所有数据，优点是速度快，不会产生内存碎片，缺点是需要2倍空间
### 垃圾回收器
前面是年轻代对应垃圾回收，后面是老年代对应垃圾回收
* Serial/Old Serial: 1.3及更早版本，通常用于小内存，应用程序，串行执行
* Parallel/Old Parallel: 1.4-1.8默认使用,并行垃圾回收，
* ParNew/CMS:1.4-1.8,
* G1:1.7-9,9开始默认使用,适用
* ZGC:11-15,15开始默认使用
> 1.8 之后的垃圾回收对大内存场景推出了G1,ZGC ，这两中垃圾回收器将内存分为多个Region，对每个Region进行类型标识
## 性能调优
* top查看内存，cpu使用情况
* 切换垃圾收集器
* 打印堆栈日志，jstack,查看锁状态
* 检查中间件状态
  * MQ中是否有消息堆积
  * redis中是否有大量数据未清理
  * sql中是否存在死锁
## 内存分布
* 元空间：存储静态信息，class信息
* 堆：
* 虚拟机栈：
* 本地方法栈：
* 程序计数器：

## 类加载机制
* 双亲委派：




java中的垃圾回收机制是自动管理内存的一种方式，它负责识别和回收不再使用的对象，
以便释放内存供其它对象使用。GC的主要目标是在对象不再被引用时自动回收内存，同时尽量减少程序
执行时的暂停时间

# 垃圾回收算法
* 标记清理：标记出所有需要回收的对象，然后清除这些对象占用的空间
* 复制算法：将内存分为两个相等的部分，垃圾回收时将存活的对象赋值到另一部分内存中,适用于新生代
* 标记整理：将存活的对象移动到内存中连续的空间避免产生内存碎片，适用用老年代
* 分代收集：将对象依据年龄划分到不同的代，依据不同年龄使用不同的回收策略？

# 垃圾回收器包括
* G1:
* ZGC:
* CMS:
* Parallel:
* ParNew:

# 内存区域划分
* 新生代
  * Eden区：刚创建的对象
  * Survior0/1区：经历一次Monitor GC后存活的对象会转到Survivor0/1区，
  经历15次Monitor GC后仍然存活的对象会被转移到老年代，通过jvm启动参数配置
* 老年代(Old Generation):大对象或15次GC后仍然存活的对象存放到老年代
* 永久代/元空间：存放类元信息，方法区
* 程序计数器：用于记录当前线程执行字节码的行号
* JVM虚拟机栈：存储线程中的变量等
* 本地方法栈：用于支持native方法执行