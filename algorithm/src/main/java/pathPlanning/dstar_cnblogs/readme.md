https://www.cnblogs.com/MyStringIsNotNull/p/16273574.html
D*算法是一种增量式的路径搜索算法，适合面对周围环境未知或者周围环境存在动态变化的场景，但也能兼容静态环境，与A*算法不同的是，A*算法从起点向目标点进行搜索，而D*算法是从目标点向起始点进行反向搜索。

ps: 启发式搜索是利用启发函数来对搜索进行指导，从而实现高效的搜索。增量搜索是对以前的搜索结果信息进行再利用来实现高效搜索，大大减少搜索范围和时间。D*算法采用反向搜索的目的在于后期需要重新规划路径的时候，能够用到先前搜索到的最短路径信息，减少搜索量。因为以目标向起始点进行搜索得到的最短路径图，是以目标点为中心辐射出的最短路径图，图上目标点到各点之间都是最短路径，为此其在既定路径上遇到问题需要重新路径规划的时候，可以很好的利用原先得到的信息。而以起始点向目标点搜索得到的最短路径图，其是以起始点为中心辐射出的最短路径图，当沿着既定路径前行遇到障碍物之后，需要重新进行路径规划之时，没有办法很好的利用原先搜索得到的信息。

算法描述：

D*算法有几个重要的概念：

G：表示进行路径搜索的目标点

c(x,y)：从节点x移动到节点y的代价

t(x)：节点的状态。每个节点(作者论文中称为state)都有一个状态，其中总共有三种可能NEW,OPEN,CLOSED。NEW表示从未加入到openList中的，也就是从未被遍历查找过的。OPEN表示节点在被查找中，节点在openList中。CLOSED表示从openList中被移出。OPEN和CLOSED状态会相互转化，当节点从openList中移出的时候，状态从OPEN变为CLOSED，当节点再次加入openList，进行 降低节点自身h值或者传播当前节点的h值变更信息给邻居节点，让邻居节点进行h值修改变更 操作时，状态从CLOSED变为OPEN

h(x)：表示地图上的点x到达目标点G的代价。由于D*算法是从目标点开始进行路径规划的，为此，初始化的时候，令h(G) = 0。此后，其代价的变动可能会在两个地方出现，一个是路径搜索的过程中，当节点x的邻居节点被执行搜索过程的时候，如果其能够让h(x)的代价更小，则更新h(x) = h(y) + cost(y,x)。一个是在路径搜索完成后执行路径搜索结果的过程中遇到障碍物之时，通过insert(x,y,val)函数改变障碍物节点y的代价h(y)

k(x)：可以理解为节点最小的h(x)值。随着节点遍历和搜索过程的进行，节点的h(x)值会不断的变动

b(x) = y：用于记录当前节点x的父节点，这里b(x) = y表示x节点的父节点为y节点。在搜索完成之后，能够根据b(x)的值，回溯追踪到目标节点

openList：存放节点状态为OPEN的节点。且其按照节点的k值从小到大进行排序